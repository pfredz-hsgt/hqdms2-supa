-- Enable UUID extension if needed (Supabase usually has it)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Create Tables
-- Note: 'users' table is removed in favor of Supabase Auth.
-- 'app_settings' is renamed to 'settings' for consistency with new API code, 
-- but we keep columns camelCase if that's what frontend expects, 
-- OR we map them. Based on analysis, frontend uses "allowNewEnrollments". 
-- Postgres stores unquoted identifiers as lowercase.
-- To minimize frontend breakage, we will use quoted identifiers for these specific columns 
-- if we want to preserve camelCase in the database, OR we assume the frontend refactor 
-- handles case insensitivity or we use views.
-- EASIEST PATH: Rename table to 'settings' and use lowercase columns. 
-- BUT frontend expects 'data.allowNewEnrollments'. 
-- If Supabase returns 'allow_new_enrollments', frontend breaks.
-- So we SHOULD use quoted identifiers to force camelCase output from PostgREST 
-- OR (better) alias them in the API code.
-- My api.js rewrite did direct select `data`.
-- So I will use quoted identifiers to keep camelCase to avoid breaking frontend.

CREATE TABLE public.settings (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "allowNewEnrollments" boolean DEFAULT true NOT NULL,
    "allowNewDrugs" boolean DEFAULT true NOT NULL,
    "allowNewDepartments" boolean DEFAULT true NOT NULL,
    "allowNewPatients" boolean DEFAULT true NOT NULL
);

-- Initialize default settings
INSERT INTO public.settings (id, "allowNewEnrollments", "allowNewDrugs", "allowNewDepartments", "allowNewPatients")
VALUES (1, true, true, false, true);

CREATE TABLE public.departments (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE TABLE public.drugs (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    department_id integer REFERENCES public.departments(id) ON DELETE CASCADE,
    quota_number integer DEFAULT 0 NOT NULL,
    active_patients integer DEFAULT 0,
    price numeric(10,2) DEFAULT 0.00 NOT NULL,
    calculation_method text DEFAULT 'monthly',
    remarks text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE TABLE public.patients (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    ic_number text NOT NULL UNIQUE,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE TABLE public.enrollments (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    drug_id integer REFERENCES public.drugs(id) ON DELETE CASCADE,
    patient_id integer REFERENCES public.patients(id) ON DELETE CASCADE,
    prescription_start_date date NOT NULL,
    prescription_end_date date,
    latest_refill_date date,
    spub boolean DEFAULT false,
    remarks text,
    cost_per_year numeric(10,2) DEFAULT 0.00,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    dose_per_day text,
    cost_per_day numeric(10,2) DEFAULT 0.00 NOT NULL,
    duration integer,
    UNIQUE(drug_id, patient_id)
);
COMMENT ON COLUMN public.enrollments.dose_per_day IS 'Dose information as free text (e.g., "10 mg tds", "5mg daily", etc.)';

CREATE TABLE public.defaulters (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    enrollment_id integer REFERENCES public.enrollments(id) ON DELETE CASCADE,
    drug_id integer REFERENCES public.drugs(id) ON DELETE CASCADE,
    patient_id integer REFERENCES public.patients(id) ON DELETE CASCADE,
    last_refill_date date,
    days_since_refill integer,
    defaulter_date date DEFAULT CURRENT_DATE,
    remarks text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- 2. Enable Row Level Security (RLS)
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.departments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.drugs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.patients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.enrollments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.defaulters ENABLE ROW LEVEL SECURITY;

-- 3. Create Policies
-- For simplicity in this migration, we'll allow authenticated users full access.
-- You can refine these policies later (e.g., read-only for some roles).

-- Allow read access to all for now (public reports?) or just authenticated?
-- Given "Login" is required for most things, authenticated is safest.
-- "Prescriber Overview" is available without login -> public read access for 'drugs' and 'enrollments' (aggregated)?
-- The Prescriber Overview likely hits APIs. If logic is client side, it needs SELECT access.
-- api.js uses ANON key.
-- If Prescriber Overview is public, we need a public read policy for relevant tables.

-- Policy: Allow full unrestricted access for authenticated users
CREATE POLICY "Enable all for users" ON public.settings FOR ALL TO authenticated USING (true);
CREATE POLICY "Enable all for users" ON public.departments FOR ALL TO authenticated USING (true);
CREATE POLICY "Enable all for users" ON public.drugs FOR ALL TO authenticated USING (true);
CREATE POLICY "Enable all for users" ON public.patients FOR ALL TO authenticated USING (true);
CREATE POLICY "Enable all for users" ON public.enrollments FOR ALL TO authenticated USING (true);
CREATE POLICY "Enable all for users" ON public.defaulters FOR ALL TO authenticated USING (true);

-- Policy: Public Read Access (for Prescriber Overview if needed, otherwise remove)
-- Assuming Prescriber Overview requires drugs and department info.
CREATE POLICY "Enable public read" ON public.departments FOR SELECT TO anon USING (true);
CREATE POLICY "Enable public read" ON public.drugs FOR SELECT TO anon USING (true);
-- enrollments might contain sensitive info, but if overview needs counts, we might need to expose it 
-- or use a secure postgres function (RPC).
-- For now, let's keep enrollments private to authenticated, unless user complains.
-- Wait, 'Login Page' has 'Prescriber Overview is available without login'.
-- This implies public access to some data.
-- I'll allow public SELECT on enrollments but maybe we should rely on RPC for privacy.
-- For simple migration:
CREATE POLICY "Enable public read" ON public.enrollments FOR SELECT TO anon USING (true);


-- 4. Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_departments_updated_at BEFORE UPDATE ON public.departments FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER update_drugs_updated_at BEFORE UPDATE ON public.drugs FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER update_patients_updated_at BEFORE UPDATE ON public.patients FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
CREATE TRIGGER update_enrollments_updated_at BEFORE UPDATE ON public.enrollments FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
